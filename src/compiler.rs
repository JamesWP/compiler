use crate::ast;
use crate::platform;
use crate::platform::x86_64_reg as reg;
use crate::platform::DecimalLiteral as DL;
use std::fmt::Display;
use std::fmt::Write;

struct CompilationState {
    output: String,
}

impl Default for CompilationState {
    fn default() -> CompilationState {
        CompilationState {
            output: String::new(),
        }
    }
}

impl CompilationState {
    fn output_comment<T: Display>(&mut self, message: T) -> std::io::Result<()> {
        writeln!(self.output, "# {}", message);
        Ok(())
    }
    fn output_section<T: Display>(&mut self, section: T) -> std::io::Result<()> {
        writeln!(self.output, "        .{}", section);
        Ok(())
    }
    fn output_type<T: Display, R: Display>(
        &mut self,
        name: T,
        symbol_type: R,
    ) -> std::io::Result<()> {
        writeln!(self.output, "        .type {}, @{}", name, symbol_type);
        Ok(())
    }
    fn output_global_specifier<T: Display>(&mut self, name: T) -> std::io::Result<()> {
        writeln!(self.output, "        .global {}", name);
        Ok(())
    }
    fn output_function_label<T: Display>(&mut self, name: T) -> std::io::Result<()> {
        writeln!(self.output, "{}:", name);
        Ok(())
    }
    fn output_newline(&mut self) -> std::io::Result<()> {
        writeln!(self.output);
        Ok(())
    }
}

macro_rules! assemble {
    ($state:expr, $nmemon:expr) => {{
        writeln!($state.output, "        {:<8} ", $nmemon);
    }};
    ($state:expr, $nmemon:expr, $arg1:expr) => {{
        write!($state.output, "        {:<8} ", $nmemon);
        writeln!($state.output, "{}", $arg1)
    }};
    ($state:expr, $nmemon:expr, $arg1:expr, $arg2:expr) => {{
        write!($state.output, "        {:<8} ", $nmemon);
        writeln!($state.output, "{}, {}", $arg1, $arg2)
    }};
}

pub fn compile(translation_unit: &ast::TranslationUnit) -> std::io::Result<String> {
    let mut state = CompilationState::default();

    state.output_comment("Begin output")?;
    state.compile_translation_unit(translation_unit)?;
    state.output_comment(format!(
        "generated by: {}",
        std::env::args().fold(String::new(), |s, a| s + " " + &a)
    ))?;
    state.output_comment("End output")?;

    Ok(state.output)
}

impl CompilationState {
    fn compile_translation_unit(
        &mut self,
        translation_unit: &ast::TranslationUnit,
    ) -> std::io::Result<()> {
        self.output_section("text")?;
        for func in &translation_unit.function_definitions {
            let (name, definition) = func;
            let statement = &definition.compound_statement;
            let parameter_list = &definition.parameter_list;

            self.output_newline()?;
            self.output_type(name, "function")?;
            self.output_global_specifier(name)?;

            // Function label
            self.output_function_label(name)?;

            // set up base pointer for frame
            // -> Does this need to change if we are not leaf?
            assemble!(self, "pushq", reg::RBP);
            assemble!(self, "movq", reg::RSP, reg::RBP);

            // Calculate layout of stack frame
            let function_stack_frame = compute_stack_layout_for_function(parameter_list);

            // Move all parameters to stack
            for param_def in function_stack_frame {
                // maybe this should be a match?
                if !param_def.reg.is_some() {
                    unimplemented!();
                }

                if !param_def.is_32_bit() {
                    unimplemented!();
                }
                assemble!(
                    self,
                    "movl",
                    param_def.reg.unwrap(),
                    param_def.stack_allocation
                );
            }

            for statement in statement.iter() {
                self.compile_statement(statement)?;
            }
        }

        Ok(())
    }

    fn compile_statement(&mut self, statement: &ast::Statement) -> std::io::Result<()> {
        match statement {
            ast::Statement::JumpStatement(ast::JumpStatement::Return) => {
                // TODO: read information about all registers which need popping
                assemble!(self, "popq", reg::RBP);
                assemble!(self, "ret");
            }
            ast::Statement::JumpStatement(ast::JumpStatement::ReturnWithValue(s)) => {
                // TODO: read information about all registers which need popping
                self.compile_expression(s, reg::EAX)?;
                assemble!(self, "popq", reg::RBP);
                assemble!(self, "ret");
            }
        }

        Ok(())
    }

    fn compile_expression(
        &mut self,
        expression: &ast::Expression,
        destination: reg,
    ) -> std::io::Result<()> {
        match expression {
            ast::Expression::Additive(lhs, rhs) => {
                unimplemented!();
            }
            ast::Expression::Unary(ast::LiteralValue::Int32(value)) => {
                assemble!(self, "movl", DL::new(value), destination);
            }
        }
        Ok(())
    }
}

fn compute_stack_layout_for_function(parameter_list: &ast::ParameterList) -> platform::StackLayout {
    let mut layout = platform::StackLayout::default();
    let mut platform_abi = platform::ParameterPlacement::default();

    let mut stack_size = 0;
    let mut next_free_location = 0;

    for (type_def, name) in parameter_list.iter() {
        // calculate which register this parameter comes in
        let param_location = platform_abi.place(type_def);

        // TODO: handle parameters which don't come in registers
        let param_reg = param_location.reg.unwrap();

        let size_in_bytes = type_def.size();

        // Make space in the stack
        stack_size += size_in_bytes;
        next_free_location += size_in_bytes;

        let location_in_stack = 0 - next_free_location as i32;

        // TODO: worry about allignment
        if size_in_bytes != 4 {
            unimplemented!();
        }
        if (next_free_location & 0x3) != 0 {
            unimplemented!();
        }

        let allocation = platform::StackRelativeLocation::new(location_in_stack, size_in_bytes);
        let param_info = platform::ParameterInfo::new(name, param_reg, type_def, allocation);
        layout.push(param_info);
    }

    layout
}
