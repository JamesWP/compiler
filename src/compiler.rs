use crate::ast;
use crate::platform;
use crate::platform::X86_64Reg as reg;
use crate::platform::DecimalLiteral as DL;
use crate::platform::Operand;
use crate::intern;
use std::collections::HashMap;
use std::collections::hash_map::Entry;
use std::fmt::Display;
use std::fmt::Write;

struct CompilationState {
    output: String,
    declarations: HashMap<String, ast::TypeDefinition>,
    function_stack_frame: Option<platform::StackLayout>,
    pub intern: intern::Intern
}

impl Default for CompilationState {
    fn default() -> CompilationState {
        CompilationState {
            output: String::new(),
            function_stack_frame: None,
            declarations: HashMap::new(),
            intern: intern::Intern::new(),
        }
    }
}

impl CompilationState {
    fn output_comment<T: Display>(&mut self, message: T) -> std::io::Result<()> {
        writeln!(self.output, "# {}", message).unwrap();
        Ok(())
    }
    fn output_section<T: Display>(&mut self, section: T) -> std::io::Result<()> {
        writeln!(self.output, "        .{}", section).unwrap();
        Ok(())
    }
    fn output_type<T: Display, R: Display>(
        &mut self,
        name: T,
        symbol_type: R,
    ) -> std::io::Result<()> {
        writeln!(self.output, "        .type {}, @{}", name, symbol_type).unwrap();
        Ok(())
    }
    fn output_global_specifier<T: Display>(&mut self, name: T) -> std::io::Result<()> {
        writeln!(self.output, "        .global {}", name).unwrap();
        Ok(())
    }
    fn output_asciiz(&mut self, data: &str) -> std::io::Result<()> {
        writeln!(self.output, ".asciz {:?}", data).unwrap();
        Ok(())
    }
    fn output_label<T: Display>(&mut self, name: T) -> std::io::Result<()> {
        writeln!(self.output, "{}:", name).unwrap();
        Ok(())
    }
    fn output_function_label<T: Display>(&mut self, name: T) -> std::io::Result<()> {
        writeln!(self.output, "{}:", name).unwrap();
        Ok(())
    }
    fn output_newline(&mut self) -> std::io::Result<()> {
        writeln!(self.output).unwrap();
        Ok(())
    }
}

macro_rules! assemble {
    ($state:expr, $nmemon:expr) => {{
        writeln!($state.output, "        {:<8} ", $nmemon).unwrap();
    }};
    ($state:expr, $nmemon:expr, $arg1:expr) => {{
        write!($state.output, "        {:<8} ", $nmemon).unwrap();
        writeln!($state.output, "{}", $arg1).unwrap();
    }};
    ($state:expr, $nmemon:expr, $arg1:expr, $arg2:expr) => {{
        write!($state.output, "        {:<8} ", $nmemon).unwrap();
        writeln!($state.output, "{}, {}", $arg1, $arg2).unwrap();
    }};
}

pub fn compile(translation_unit: &ast::TranslationUnit) -> std::io::Result<String> {
    let mut state = CompilationState::default();

    state.output_comment("Begin output")?;
    state.compile_translation_unit(translation_unit)?;

    state.output_comment("Data time!")?;
    state.output_section("data");
    for (label, data) in state.intern.get_labels() {
        state.output_label(&label)?;
        state.output_asciiz(&data)?;
    }

    state.output_comment(format!(
        "generated by: {}",
        std::env::args().fold(String::new(), |s, a| s + " " + &a)
    ))?;
    state.output_comment("End output")?;

    Ok(state.output)
}

impl CompilationState {
    fn compile_translation_unit(
        &mut self,
        translation_unit: &ast::TranslationUnit,
    ) -> std::io::Result<()> {
        self.output_section("text")?;
        for func in &translation_unit.function_definitions {
            let (name, definition) = func;


            let parameter_list = &definition.parameter_list;

            match self.declarations.entry(name.to_owned()) {
                Entry::Occupied(o) => {
                    let decl_type = o.get();

                    if let ast::TypeDefinition::FUNCTION(return_type, parameters) = decl_type {
                        if return_type.as_ref() != &definition.return_type {
                            unimplemented!("Function redeclared with different return type. {}, {:?} different from {:?}", name, return_type, definition.return_type);
                        }

                        if parameters.len() != definition.parameter_list.len() {
                            unimplemented!("Function redeclared with different number of arguments. {}, {} different from {}", name, parameters.len(), definition.parameter_list.len());
                        }

                        for (a, b) in parameters.iter().zip(definition.parameter_list.iter()) {
                            if a.0 != b.0 {
                                unimplemented!("Function redeclared with different type argument. {}, {:?} different from {:?}", name, a.0, b.0);
                            }
                        }
                    }
                },
                Entry::Vacant(e) => { 
                    e.insert(definition.return_type.clone().as_function_taking(definition.parameter_list.clone()));
                },
            }

            println!("{}, statement {:?}", name, definition.compound_statement);
            if definition.compound_statement.is_none() {
                // skip declaration
                continue;
            }

            let statement = definition.compound_statement.as_ref().unwrap();

            self.output_newline()?;
            self.output_type(name, "function")?;
            self.output_global_specifier(name)?;

            // Function label
            self.output_function_label(name)?;

            // set up base pointer for frame
            // -> Does this need to change if we are not leaf?
            assemble!(self, "pushq", reg::RBP);
            assemble!(self, "movq", reg::RSP, reg::RBP);

            // Calculate layout of stack frame
            self.function_stack_frame = Some(compute_stack_layout_for_function(parameter_list));

            let mut platform_abi = platform::ParameterPlacement::default();

            // Move all parameters to stack
            for (stack_location, (_, decl_type)) in self.function_stack_frame.as_ref().unwrap().iter().zip(parameter_list.iter()) {
                // calculate which register this parameter comes in
                let param_location = platform_abi.place(decl_type);

                // TODO: handle parameters which don't come in registers
                let param_reg = param_location.reg.unwrap();

                let op = match stack_location.size() {
                    1 => "movb",
                    4 => "movl",
                    8 => "movq",
                    _ => unimplemented!()
                };

                assemble!(
                    self,
                    op,
                    param_reg,
                    stack_location.stack_allocation
                );
            }

            // Allocate space for all local variables
            for declaration in definition.declarations() {
                let (name, type_def) = declaration;
                let size = type_def.size();
                self.function_stack_frame.as_mut().unwrap().allocate(&name, &type_def, size);
                match self.declarations.entry(name) {
                    Entry::Occupied(_) => todo!(),
                    Entry::Vacant(e) => {
                        e.insert(type_def);
                    },
                }
            }

            // Fix stack pointer
            let stack_size = self.function_stack_frame.as_ref().unwrap().stack_size;
            if stack_size != 0 {
                assemble!(self, "subq", DL::new(stack_size as i32), reg::RSP);
            }

            for statement in statement.iter() {
                self.compile_statement(statement)?;
            }

            let stack_comments: Vec<_> = self.function_stack_frame
                .as_ref()
                .unwrap()
                .iter()
                .map(|x| format!("{:10} in {:?}", format!("{}", x.stack_allocation), x.name))
                .collect();

            for x in stack_comments {
                self.output_comment(x)?;
            }
        }

        Ok(())
    }

    fn compile_statement(&mut self, statement: &ast::Statement) -> std::io::Result<()> {
        match statement {
            ast::Statement::JumpStatement(ast::JumpStatement::Return) => {
                let stack_size = self.function_stack_frame.as_ref().unwrap().stack_size;
                if stack_size != 0 {
                    assemble!(self, "movq", reg::RBP, reg::RSP);
                }
                // TODO: read information about all registers which need popping
                assemble!(self, "popq", reg::RBP);
                assemble!(self, "ret");
            }
            ast::Statement::JumpStatement(ast::JumpStatement::ReturnWithValue(s)) => {
                // TODO: read information about all registers which need popping
                self.compile_expression(s, Some(&reg::EAX))?;
                let stack_size = self.function_stack_frame.as_ref().unwrap().stack_size;
                if stack_size != 0 {
                    assemble!(self, "movq", reg::RBP, reg::RSP);
                }
                assemble!(self, "popq", reg::RBP);
                assemble!(self, "ret");
            }
            ast::Statement::Declaration(declaration) => {
                let name = &declaration.name;
                let location = self.function_stack_frame.as_ref().unwrap().get_location(name)?;
                if let Some(e) = &declaration.expression {
                    self.compile_expression(&e, Some(&location))?;
                }
            }
            ast::Statement::Expression(e) => {
                self.compile_expression::<reg>(e, None)?;
            },
        }

        Ok(())
    }

    fn compile_expression<Dest: Operand>(
        &mut self,
        expression: &ast::Expression,
        destination: Option<&Dest>,
    ) -> std::io::Result<()> {
        let scratch_register_64 = reg::RDI;
        let scratch_register_32 = reg::EDI;

        match expression {
            ast::Expression::Additive(lhs, rhs) => {
                self.compile_expression(lhs.as_ref(), destination)?;

                if let Some(destination) = destination {
                    // store result of expression on stack temporarily
                    assemble!(self, "movl" , destination, scratch_register_32);
                    assemble!(self, "pushq", scratch_register_64);
                }

                self.compile_expression(rhs, destination)?;

                if let Some(destination) = destination {
                    // retreive the value of the lhs
                    assemble!(self, "popq", scratch_register_64);
                    assemble!(self, "addl", scratch_register_32, destination);
                }
            }
            ast::Expression::Unary(ast::Value::Literal(ast::LiteralValue::Int32(value))) => {
                if let Some(destination) = destination {
                    assemble!(self, "movl", DL::new(value), destination);
                }
            }
            ast::Expression::Unary(ast::Value::Literal(ast::LiteralValue::StringLiteral(value))) => {
                if let Some(destination) = destination {
                    let label = self.intern.add(value);
                    assemble!(self, "lea", format!("{}(%rip)", label), destination);
                }
            }
            ast::Expression::Unary(ast::Value::Identifier(name)) => {
                let location = self.function_stack_frame.as_ref().unwrap().get_location(name)?;
                if let Some(destination) = destination {
                    if location.is_memory() && destination.is_memory() {
                        // use scratch register to hold rhs value. as add can only have a single memory operand.
                        assemble!(self, "movl", location, scratch_register_32);
                        assemble!(self, "movl", scratch_register_32, destination);
                    } else {
                        assemble!(self, "movl", location, destination);
                    }
                }
            }
            ast::Expression::Call(a,args) => {
                // TODO: check function types
                if !self.declarations.contains_key(a) {
                    unimplemented!("Function not defined {}", a);
                }
                
                let mut param_place = platform::ParameterPlacement::default();
               
                for arg in args {
                    let expr_type = compute_expression_type(arg);
                    let param = param_place.place(&expr_type);
                    if let Some(ref reg) = param.reg {
                        self.compile_expression(arg, Some(reg))?;
                    } else {
                        unimplemented!();
                    }
                }
                // assemble call instruction
                assemble!(self, "call", a);

                if let Some(destination) = destination {
                    if destination.is_memory() || destination.reg() != Some(&reg::EAX) {
                        assemble!(self, "movl", reg::EAX, destination);
                    }
                }
            }
        }
        Ok(())
    }
}

fn compute_expression_type(expr: &ast::Expression) -> ast::TypeDefinition {
    match expr {
        ast::Expression::Additive(a, b) => {
            let a_type = compute_expression_type(a);
            let b_type = compute_expression_type(b);

            if a_type == b_type {
                compute_expression_type(a)
            } else {
                unimplemented!();
            }
        },
        ast::Expression::Unary(v) => match v {
            ast::Value::Literal(v) => match v {
                ast::LiteralValue::Int32(_) => ast::TypeDefinition::INT(false.into()), /* this dosen't make sense, why is type spec needed here? */
                ast::LiteralValue::StringLiteral(_) => ast::TypeDefinition::POINTER(false.into(), Box::new(ast::TypeDefinition::CHAR(false.into()))),
            },
            ast::Value::Identifier(_) => todo!(),
        },
        ast::Expression::Call(_, _) => todo!(),
    }
}

fn compute_stack_layout_for_function(parameter_list: &ast::ParameterList) -> platform::StackLayout {
    let mut layout = platform::StackLayout::default();
    
    for (name, decl_type) in parameter_list.iter() {
        let size_in_bytes = decl_type.size();
        layout.allocate(name, decl_type, size_in_bytes);
    }

    layout
}